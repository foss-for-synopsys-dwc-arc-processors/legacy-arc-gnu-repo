/* Target dependent code for ARC700, for GDB, the GNU debugger.

   Copyright 2005 Free Software Foundation, Inc.

   Contributed by Codito Technologies Pvt. Ltd. (www.codito.com)

   Authors:
      Sameer Dhavale <sameer.dhavale@codito.com>
      Ramana Radhakrishnan <ramana.radhakrishnan@codito.com>

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*/

/******************************************************************************/
/*                                                                            */
/* Outline:                                                                   */
/*     This module creates an instance of a gdb 'target_ops' structure which  */
/*     contains information and operations for debugging a remote ARC target  */
/*     with JTAG.                                                             */
/*                                                                            */
/*     It also registers a number of ARC-specific commands with gdb.          */
/*                                                                            */
/* Usage:                                                                     */
/*     The module exports a function _initialize_arc_debug: the call to this  */
/*     function is generated by the gdb build mechanism, so this function     */
/*     should not be explicitly called.                                       */
/*                                                                            */
/******************************************************************************/

/* system header files */
#include <assert.h>
#include <signal.h>

/* gdb header files */
#include "defs.h"
#include "inferior.h"
#include "gdbcore.h"
#include "regcache.h"
#include "breakpoint.h"
#include "exceptions.h"
#include "gdbcmd.h"

/* ARC header files */
#include "arc-jtag.h"
#include "arc-jtag-ops.h"
#include "arc-jtag-actionpoints.h"
#include "arc-tdep.h"
#include "arc-support.h"


/* -------------------------------------------------------------------------- */
/*                               local types                                  */
/* -------------------------------------------------------------------------- */

typedef enum
{
    RO,    // read-only
    RW,    // read/write
    WO     // write-only
} RegisterMode;


typedef struct arc_reg_info
{
    const char*              name;
    ARC_HardwareRegisters    hw_regno;
    enum arc700_jtag_regnums gdb_regno;
    RegisterMode             mode;
} RegisterInfo;


/* -------------------------------------------------------------------------- */
/*                               local data                                   */
/* -------------------------------------------------------------------------- */

#define INVALID_REGISTER_NUMBER    (ARC_RegisterNumber) 0xFFFFFFFFU

#define ARC_NR_CORE_REGS           64


#undef RAUX
#undef RBCR
#define RBCR(name, hwregno, desc, gdbregno, mask, mode, version) { #name, hwregno, gdbregno, mode },
static const RegisterInfo arc_bcr_reg_info[] =
{
   #include "arc-regnums-defs.h"
};

#undef RAUX
#undef RBCR
#define RAUX(name, hwregno, desc, gdbregno, mask, mode, version) { #name, hwregno, gdbregno, mode },
static const RegisterInfo arc_aux_reg_map[] =
{
    #include "arc-regnums-defs.h"
};


static struct target_ops arc_debug_ops;

/* For the ^C signal handler.  */
static void (*ofunc) (int);


/* -------------------------------------------------------------------------- */
/*                               external data                                */
/* -------------------------------------------------------------------------- */

/* this declaration should be in the file breakpoint.h (a gdb core file) */
extern struct breakpoint *breakpoint_chain;


/* -------------------------------------------------------------------------- */
/*                               local macros                                 */
/* -------------------------------------------------------------------------- */

#define IS_CORE_REGISTER(regno)     (regno < ARC_NR_CORE_REGS)


/* -------------------------------------------------------------------------- */
/*                               local functions                              */
/* -------------------------------------------------------------------------- */

static void arc_debug_interrupt_twice (int signo);


/* Determine whether the given register is read-only. */
static Boolean
is_read_only(int regno)
{
    unsigned int i;

    /* the core registers are all read/write */
    if (0 <= regno && regno <= 31)
        return FALSE;

    /* the extension core registers do not exist, so they are not writeable;
     * R61 is reserved, R62 is not a real register, and R63 (PCL) is read-only
     */
    if ((32 <= regno && regno <= 59) || (61 <= regno && regno <= 63))
        return TRUE;

    /* the build configuration registers are read-only */
    if (ARC_BCR_1_REGNUM <= regno && regno <= ARC_BCR_1F_REGNUM)
        return TRUE;

    /* check whether it is an auxiliary register */
    for (i = 0; i < ELEMENTS_IN_ARRAY(arc_aux_reg_map); i++)
    {
        if (arc_aux_reg_map[i].gdb_regno == regno)
            return (arc_aux_reg_map[i].mode == RO);
    }

    /* if we can not identify it, assume it is R/O */
    return TRUE;
}


/* Read core register. Return True on success. */
static Boolean
read_core_register (ARC_RegisterNumber hwregno, ARC_RegisterContents* contents)
{
    if (arc_jtag_ops.jtag_read_core_reg(hwregno, contents) == JTAG_SUCCESS)
        return TRUE;

    warning("Failure reading core register 0x%x", hwregno);
    return FALSE;
}


/* Write core register. Return True on success. */
static Boolean
write_core_register (ARC_RegisterNumber hwregno, ARC_RegisterContents contents)
{
    if (arc_jtag_ops.jtag_write_core_reg(hwregno, contents) == JTAG_SUCCESS)
        return TRUE;

    warning("Failure writing 0x%x to core register 0x%x", contents, hwregno);
    return FALSE;
}


static void
debug_fetch_register (ARC_RegisterNumber hw_regno, int gdb_regno)
{
    ARC_RegisterContents contents;
    Boolean              register_read;

    if (IS_CORE_REGISTER(gdb_regno))
        register_read = read_core_register(hw_regno, &contents);
    else
        register_read = arc_read_aux_register (hw_regno, &contents);

    if (register_read)
    {
        DEBUG("Read 0x%x from register %d\n", contents, hw_regno);

        regcache_raw_supply (current_regcache, gdb_regno, &contents);
    }

    LEAVEMSG;
}


static void
debug_fetch_reg (const RegisterInfo* info)
{
    debug_fetch_register ((ARC_RegisterNumber) info->hw_regno, info->gdb_regno);
}


static void
debug_store_register (ARC_RegisterNumber hw_regno, int gdb_regno)
{
    ARC_RegisterContents contents;
    Boolean              register_written;

    regcache_raw_collect(current_regcache, gdb_regno, &contents);

    if (IS_CORE_REGISTER(gdb_regno))
        register_written = write_core_register(hw_regno, contents);
    else
        register_written = arc_write_aux_register (hw_regno, contents);

    if (register_written)
    {
        DEBUG("Written value 0x%08X to regno %d\n", hw_regno, contents);
    }
}


static void
debug_store_reg (const RegisterInfo* info)
{
    if (!is_read_only(info->gdb_regno))
        debug_store_register ((ARC_RegisterNumber) info->hw_regno, info->gdb_regno);
}


static ARC_RegisterNumber
get_hw_regnum_mapping (int gdb_regno)
{
    if (IS_CORE_REGISTER(gdb_regno))
        return (ARC_RegisterNumber) gdb_regno;

    if (gdb_regno < ARC_NR_REGS)
    {
        unsigned int i;

        if (ARC_STATUS_REGNUM <= gdb_regno && gdb_regno <= ARC_AUX_IRQ_PENDING_REGNUM)
            return (ARC_RegisterNumber) arc_aux_reg_map[gdb_regno - ARC_STATUS_REGNUM].hw_regno;

        for (i = 0; i < ELEMENTS_IN_ARRAY(arc_bcr_reg_info); i++)
        {
            if (gdb_regno == arc_bcr_reg_info[i].gdb_regno)
                return (ARC_RegisterNumber) arc_bcr_reg_info[i].hw_regno;
        }
    }

    /* not found */
    return INVALID_REGISTER_NUMBER;
}


/* Set UB bit in the DEBUG register. It allows brk_s to work in user mode.  */
static void
set_debug_user_bit (ARC_RegisterContents extra_bits)
{
    if (IS_ARC700)
    {
        ARC_RegisterContents debug;

        if (arc_read_aux_register (ARC_HW_DEBUG_REGNUM, &debug))
        {
            /* set UB = 1 */
            ARC_RegisterContents new_debug = debug | DEBUG_USER | extra_bits;

            /* do the write only if it will change the register contents */
            if (new_debug != debug)
                if (!arc_write_aux_register(ARC_HW_DEBUG_REGNUM, new_debug))
                    warning("Can not set DEBUG register to 0x%08X\n", new_debug);
        }
        else
            warning("Can not set User bit in DEBUG register\n");
    }
}


static void
invalidateCaches (void)
{
    if (arc_jtag_ops.jtag_write_aux_reg (ARC_HW_ICACHE_IVIC, 1) == JTAG_WRITE_FAILURE)
        warning("Failure writing 0x1 to auxiliary register 0x%x: Icache invalidate", ARC_HW_ICACHE_IVIC);

    if (arc_jtag_ops.jtag_write_aux_reg (ARC_HW_DCACHE_IVIC, 1) == JTAG_WRITE_FAILURE)
        warning("Failure writing 0x1 to auxiliary register 0x%x: Dcache invalidate", ARC_HW_DCACHE_IVIC);
}


static void
disableCaches (void)
{
    /* Disabling Icache */
    if (arc_jtag_ops.jtag_write_aux_reg(ARC_HW_ICACHE_CONTROL, 1) == JTAG_WRITE_FAILURE)
        warning("Failure writing 0x1 to auxiliary register 0x%x: Icache control", ARC_HW_ICACHE_CONTROL);

    /* Disabling Dcache */
    if (arc_jtag_ops.jtag_write_aux_reg(ARC_HW_DCACHE_CONTROL, 1) == JTAG_WRITE_FAILURE)
        warning("Failure writing 0x1 to auxiliary register 0x%x: Dcache control", ARC_HW_DCACHE_CONTROL);
}


static void
update_architecture(void)
{
    struct gdbarch_tdep* tdep    = gdbarch_tdep (current_gdbarch);
    ARC_ProcessorVersion version = arc_get_architecture();

    tdep->processor_variant_info->processor_version = version;

    switch (version)
    {
        case UNSUPPORTED:
            break;
        case ARCompact:
            break;
        case ARC600:
            set_gdbarch_decr_pc_after_break (current_gdbarch, 2);
            break;
        case ARC700:
            set_gdbarch_decr_pc_after_break (current_gdbarch, 0);
            break;
        case A5:
             warning ("A5 debugging is unsupported and may be unreliable.");
            break;
        case A4:
            /* N.B. this will not return */
            error ("A4 debugging is unsupported.");
            break;
    }

    /* we do not know whether the target processor supports actionpoints until
     * after we have connected to it, as we have to read the AP_BUILD auxiliary
     * register to find that out!
     */
    (void) arc_init_actionpoint_ops(&arc_debug_ops);
}


/* -------------------------------------------------------------------------- */
/*               local functions called from outside this module              */
/* -------------------------------------------------------------------------- */

/* Function: arc_debug_open
 * Parameters :
 * 1. args :
 * 2. from_tty:
 * Returns : void
 * Description:
        1. Connect to the jtag target .
        2. Read the number of action points supported.
        3. Read the configuration of action points.
        4. Set up internal data structures for number of hardware
           breakpoints and watchpoints.
        5. Set the UB bit to 1 for ARC700 and not for ARC600.
 */

static void
arc_debug_open (char *args, int from_tty)
{
    Boolean opened;

    ENTERARGS("%s", args);

    target_preopen(from_tty);

    /* N.B should these be called here? */
    reopen_exec_file ();
    reread_symbols ();

    gdb_assert(arc_jtag_ops.jtag_open != NULL);

    (void) unpush_target (&arc_debug_ops);

    opened = arc_jtag_ops.jtag_open();

    if (!opened)
    {
        /* N.B. error does not return! */
        error("Can not connect to target\n");
    }

    /* Call update_architecture if opened successfully.
     * N.B. this MUST be done before push_target is called!
     */
    update_architecture();

    (void) push_target (&arc_debug_ops);

    /* FIXME: Should these be in create_inferior or somewhere else? We would
     *        not like these here when attach starts working.
     */
    disableCaches();

    if (!arc_write_aux_register (ARC_HW_STATUS32_REGNUM, STATUS32_HALT))
        warning("Can not set Halt bit in STATUS32 register");

    /* allow breakpoints in user mode.  */
    set_debug_user_bit (0);

    if (from_tty)
        printf_filtered ("Connected to the " ARC_TARGET_NAME " target.\n");
}


static void arc_debug_close()
{
    arc_jtag_ops.jtag_close();
}


/* Function: arc_debug_attach
 * Parameters :
 * 1. char *x:
 * 2. int i:
 * Returns : void
 * Description:
 *  1. attach without resetting the board
 *  2. get all Board configuration registers of interest.
 *  if ARC700 set the UB bit to 1. (This is invalid in the ARC600).
 */

static void
arc_debug_attach (char *x, int i)
{
    ENTERMSG;
}


/* Function: arc_debug_attach
 * Parameters :
 * 1. char *x:
 * 2. int i:
 * Returns : void
 * Description:
 *  1. Detach without resetting the board.
 */
static void
arc_debug_detach (char *x, int i)
{
    ENTERMSG;

    /* Let it continue. */
    target_resume (inferior_ptid, 0, 0);
}


/* Function: arc_debug_resume
 * Make the inferior resume execution, sending a signal if necessary.
 * Parameters :
 * 1. ptid_t ptid:
 * 2. int step: 1 - single step, 0 run freely.
 * 3. enum target_signal signal;
 * Returns : void
 * Description:
 *      1. What about Pipecleaning?
 *      2. Write 0 to the HALT bit in status32.
 *      3. Send a signal (ignore) in this case.
 *      4. if (step) use hardware single step on the ARC700.
 *          done by setting the IS bit in the debug register
 *          and clearing the halt bit in status32.
 *
 */

static void
arc_debug_resume (ptid_t ptid, int step, enum target_signal signal)
{
    ENTERARGS("%d, %d, %d", ptid.pid, step, signal);

    /* Because breakpoints may have been set/removed.  */
    invalidateCaches ();

    /* The DEBUG User bit must be set if breakpoints are to be allowed in user
     * mode. We set it in target_open, but the operating system might clear it.
     * So we set it every time we resume (if stepping, we set the extra bit we
     * need in the DEBUG register in the same operation).
     */

    if (step)
    {
        ARC_RegisterContents mask = 0;

        DEBUG("setting DEBUG.IS bit for single-step\n");

        /* Mask for Single Stepping changes between ARC600 and ARC700. */
        if (IS_ARC700)
            mask = 0x00000800;
        else
            if (IS_ARC600)
                mask = 0x00000801;

        /* Set IS bit in DEBUG register for hardware single instruction stepping. */
        set_debug_user_bit (mask);
    }
    else
    {
        ARC_RegisterContents status32;

        set_debug_user_bit (0);

        /* Restarting the processor by clearing the 'H' bit in the status register*/

        if (!arc_read_aux_register (ARC_HW_STATUS32_REGNUM, &status32) ||
            !arc_write_aux_register(ARC_HW_STATUS32_REGNUM,  status32 & ~STATUS32_HALT))
            warning ("Can not clear Halt bit in STATUS32 register\n");
    }

    LEAVEMSG;
}


/* The command line interface's stop routine.  This function is installed as
 * a signal handler for SIGINT.  The first time a user requests a stop, we
 * call target_stop to send a break or ^C.  If there is no response from the
 * target (it didn't stop when the user requested it), we ask the user if
 * he'd like to detach from the target.
 */
static void
arc_debug_interrupt (int signo)
{
    /* If we get the signal twice, do something more drastic.  */
    (void) signal (signo, arc_debug_interrupt_twice);

    target_stop ();
}


/* The user typed ^C twice.  */
static void
arc_debug_interrupt_twice (int signo)
{
    (void) signal (signo, ofunc);

    if (query("Interrupted while waiting for the program. "
              "Give up (and stop debugging it)?"))
    {
        struct gdb_exception exception = {RETURN_QUIT,
                                          GDB_NO_ERROR,
                                          "Interrupted by user"};
        target_mourn_inferior();
        DEBUG("arc_debug_interrupt_twice: throwing exception\n");
        throw_exception (exception);
    }

    (void) signal (signo, arc_debug_interrupt);
}


/* Function: arc_debug_wait
 * Parameters :
 * 1. ptid_t ptid:
 * 2. struct target_waitstatus *status: Indicates status at end
                                        of wait for F.E.
 * Returns : ptid
 * Description:
 *        Poll status32 for the value of H bit.
 *        After H bit is set in status32.
 *        Wait till LD(load pending bit) in the DEBUG register
 *        is cleared.
 *        SH bit is set if flag instruction was used to halt the processor.
 *        BH bit is set if the ARCompact processor stopped due to
 *        a brk_s instruction. Set the target_waitstatus (signal) to SIGTRAP
 *        only in such a situation.
 *
 */

static ptid_t
arc_debug_wait (ptid_t ptid, struct target_waitstatus *status)
{
    ARC_RegisterContents debug;

    ENTERMSG;

    /* signal handler for Control-C.  */
    ofunc = signal (SIGINT, arc_debug_interrupt);

    arc_jtag_ops.jtag_wait();

    /* put the old function back.  */
    (void) signal (SIGINT, ofunc);

    /* inform the actionpoints module that the target has halted */
    arc_target_halted();

    /* If the DEBUG.SH ("self halt") bit is set, we stopped because of the flag
     * instruction, which is used by programs to exit.
     */
    if (arc_read_aux_register (ARC_HW_DEBUG_REGNUM, &debug))
    {
        /* test SH bit of debug register */
        if (debug & DEBUG_SH)
        {
            ARC_RegisterContents exitcode;

            status->kind = TARGET_WAITKIND_EXITED;

            /* Exit code of the program (in R0). */
            if (!read_core_register(0, &exitcode))
            {
                warning ("Assuming exit code = 0");
                status->value.integer = 0;
            }
            else
                status->value.integer = (int) exitcode;
        }
        else
        {
            status->kind      = TARGET_WAITKIND_STOPPED;
            status->value.sig = TARGET_SIGNAL_TRAP;
        }
    }
    else
        warning ("Can not read DEBUG register\n");


    /* Bug #1311 (ARC600): Setting a breakpoint on the last instruction of a
     * ZOL causes GDB to stop at LP_START.  Detect this condition and warn the
     * user.
     */
    if (IS_ARC600)
    {
        ARC_RegisterContents pc, lp_start, lp_end, lp_count;

        if (read_core_register    (ARC_LP_COUNT_REGNUM,    &lp_count) && (lp_count != 0)  &&
            arc_read_aux_register (ARC_HW_PC_REGNUM,       &pc)                           &&
            arc_read_aux_register (ARC_HW_LP_START_REGNUM, &lp_start) && (pc == lp_start) &&
            arc_read_aux_register (ARC_HW_LP_END_REGNUM,   &lp_end))
        {
            struct breakpoint *b;

            for (b = breakpoint_chain; b != NULL; b = b->next)
            {
                /* lp_end is the address of the last instruction + the size of
                 * the last instruction.  We could use the disassembler and find
                 * out the size, but it's easier just to try both possible sizes.
                 *
                 * N.B. the pending flag is not present in gdb 6.8!
                 */
                if ((b->enable_state == bp_enabled && !b->pending) &&
                    (b->loc->address == lp_end - 4 || b->loc->address == lp_end - 2))
                {
                    warning ("Did you set a breakpoint on the last instruction of "
                              "a Zero Overhead Loop? Such breakpoints do not work properly.");
                }
            }
        }
    }

    return inferior_ptid;
}


/* Function: arc_debug_fetch_regs.
 *
 * Parameters :
 *    1. int regnum: Register number (-1 means all registers)
 * Returns : void
 */
static void
arc_debug_fetch_regs (int regno)
{
    ENTERARGS("%d", regno);

    /* all registers */
    if (regno == -1)
    {
        unsigned int i;

        /* core registers */
        for (i = 0; i < ARC_NR_CORE_REGS; i++)
            debug_fetch_register((ARC_RegisterNumber) i, (int) i);

        /* aux registers */
        for (i = 0; i < ELEMENTS_IN_ARRAY(arc_aux_reg_map); i++)
            debug_fetch_reg(&arc_aux_reg_map[i]);

        /* build configuration registers */
        for (i = 0; i < ELEMENTS_IN_ARRAY(arc_bcr_reg_info); i++)
            debug_fetch_reg(&arc_bcr_reg_info[i]);
    }
    else
    {
        ARC_RegisterNumber hw_regno = get_hw_regnum_mapping (regno);

        if (hw_regno == INVALID_REGISTER_NUMBER)
            error("Invalid Register Number");
        else
            debug_fetch_register(hw_regno, regno);
    }

    LEAVEMSG;
}


/* Function: arc_debug_store_regs.
 *
 * Parameters :
 *    1. int regnum: Register number (-1 means all registers)
 * Returns : void
 */
static void
arc_debug_store_regs (int regno)
{
    ENTERARGS("%d", regno);

    /* all registers */
    if (regno == -1)
    {
        unsigned int i;

        /* core registers */
        for (i = 0; i < ARC_NR_CORE_REGS; i++)
            debug_store_register((ARC_RegisterNumber) i, (int) i);

        /* aux registers */
        for (i = 0; i < ELEMENTS_IN_ARRAY(arc_aux_reg_map); i++)
            debug_store_reg(&arc_aux_reg_map[i]);

        /* build configuration registers are not writable */
    }
    else
    {
        ARC_RegisterNumber hw_regno = get_hw_regnum_mapping (regno);

        if (hw_regno == INVALID_REGISTER_NUMBER)
            error("Invalid register number: %d", regno);
        else
            debug_store_register(hw_regno, regno);
    }

    LEAVEMSG;
}


/* Function: arc_debug_prepare_to_store.
 * Returns : void
 * Description:
 *          Use deprecated register information for this.
 */

/* This gets called just before store_regs */
static void
arc_debug_prepare_to_store (void)
{
    ENTERMSG;
}


/* Read or write memory or auxiliary registers
 *
 *   if 'object' is TARGET_OBJECT_MEMORY then
 *       if 'writebuf' is NULL
 *           read 'len' bytes of data from target memory starting at address 'offset' to 'readbuf'
 *       else
 *           write 'len' bytes of data from 'writebuf' to target memory starting at address 'offset'
 *   else
 *       if 'object' is ARC_TARGET_OBJECT_AUXREGS then
 *           if 'writebuf' is non-NULL then
 *               set contents of 'len' AUX registers starting at number 'offset' from 'writebuf'
 *           else
 *               get contents of 'len' AUX registers starting at number 'offset' into 'readbuf'
 *
 *    returns number of bytes of memory, or number of registers, read/written
 */

static LONGEST
arc_debug_xfer_partial (struct target_ops *ops,        // unused
                        enum target_object object,
                        const char        *annex,      // unused
                        gdb_byte          *readbuf,
                        const gdb_byte    *writebuf,
                        ULONGEST           offset,
                        LONGEST            len)
{
    ENTERARGS("offset 0x%x len %lld", (unsigned int) offset, len);

    /* Handle memory */
    if (object == TARGET_OBJECT_MEMORY)
    {
        /* Get out of user mode so that we can read/write anything anywhere.  */
        ARC_RegisterContents saved_status32 = arc_clear_status32_user_bit ();
        unsigned int         xfered;

        /* No need to worry about the alignment of the address 'offset' - the
         * JTAG memory read/write operations handle that.
         */
        if (writebuf != NULL)
        {
            xfered = arc_jtag_ops.jtag_memory_write_chunk
                         ((ARC_Address)  offset,
                          (ARC_Byte*)    writebuf,
                          (unsigned int) len);

            DEBUG("...leaving %s(memory write) with return value %u\n",
                  __FUNCTION__, xfered);
        }
        else /* read data */
        {
            xfered = arc_jtag_ops.jtag_memory_read_chunk
                         ((ARC_Address)  offset,
                          (ARC_Byte*)    readbuf,
                          (unsigned int) len);

            DEBUG("...leaving %s(memory read) with return value %u\n",
                  __FUNCTION__, xfered);
        }

        arc_restore_status32_user_bit (saved_status32);

        return (LONGEST) xfered;
    }

    /* ARC auxiliary registers: they are 32 bits wide and are in a 32 bit
     * address space, although only part of the address space is used.
     */
    else if (object == ARC_TARGET_OBJECT_AUXREGS)
    {
        ARC_RegisterNumber regno = (ARC_RegisterNumber) offset;
        ARC_RegisterNumber limit = (ARC_RegisterNumber) (offset + len);
        unsigned int       count = 0;

        while (regno < limit)
        {
            if (readbuf)
            {
                if (!arc_read_aux_register (regno, &((ARC_RegisterContents*) readbuf)[count]))
                    /* return number of registers read so far */
                    break;
            }
            else if (writebuf)
            {
                if (!arc_write_aux_register (regno, ((ARC_RegisterContents*) writebuf)[count]))
                    /* return number of registers written so far */
                    break;
            }

            regno++;
            count++;
        }

        /* return number of registers read/written */
        return (LONGEST) (count);
    }
    else
    {
        printf("\nRequested target_object not yet supported with arc-jtag\n");
    }

    return -1;
}


static void
arc_debug_files_info (struct target_ops *target)
{
    /* Do nothing. Just say it's a remote target */
    ENTERMSG;
}


/* Function: arc_debug_insert_breakpoint
 * Parameters :
 * 1. CORE_ADDR addr: Address for breakpoint.
 * 2. char * contents: Contents for the breakpoint.
 * Returns : int - 0 for success.
 * Description:
 * See if you can insert a hardware breakpoint using the actionpoints
 * interface. Use brk_s if architecture is ARC700 and you need to use
 * a software breakpoint.The gdbarch breakpoint should be initialized to
 * the right value if used with target_arc_debug.
 */

static int arc_debug_insert_breakpoint (struct bp_target_info* bpt)
{
    const unsigned char *breakpt_instruction;
    unsigned int         bytes;

    ENTERARGS("0x%08X", (unsigned int) bpt->placed_address);

    breakpt_instruction = BREAKPOINT_FROM_PC(&bpt->placed_address,
                                             &bpt->placed_size);

    /* FIXME: alignment of breakpt_instruction! */
    DEBUG("breakpoint size = %d and breakpoint instruction 0x%x\n",
          bpt->placed_size, *(unsigned int *) breakpt_instruction);

    /* save the existing instruction at the given address */
    bytes = arc_jtag_ops.jtag_memory_read_chunk
                ((ARC_Address)  bpt->placed_address,
                 (ARC_Byte*)    bpt->shadow_contents,
                 (unsigned int) bpt->placed_size);

    if (bytes == (unsigned int) bpt->placed_size)
        /* overwrite the instruction with the breakpoint instruction */
        bytes = arc_jtag_ops.jtag_memory_write_chunk
                    ((ARC_Address)  bpt->placed_address,
                     (ARC_Byte*)    breakpt_instruction,
                     (unsigned int) bpt->placed_size);

    return (bytes == (unsigned int) bpt->placed_size) ? 0 : 1;
}


/* Function: arc_debug_remove_breakpoint.
 * Parameters :
 * 1. CORE_ADDR addr: Address.
 * 2. char * contents : contents.
 * Returns : int - 0 for success.
 * Description:
 *  Write the old contents back for the breakpoint.
 *
 */

static int arc_debug_remove_breakpoint (struct bp_target_info* bpt)
{
    unsigned int bytes;

    /* FIXME: alignment of shadow_contents! */
    ENTERARGS("0x%08X, 0x%lx", (unsigned int)     bpt->placed_address,
                               *(unsigned long *) bpt->shadow_contents);

    /* write the old code back */
    bytes = arc_jtag_ops.jtag_memory_write_chunk
                ((ARC_Address)  bpt->placed_address,
                 (ARC_Byte*)    bpt->shadow_contents,
                 (unsigned int) bpt->placed_size);

    return (bytes == (unsigned int) bpt->placed_size) ? 0 : 1;
}


/* Function: arc_debug_kill
 * Parameters : void.

 * Returns : void.
 * Description: Heavy duty arsenal.Kill the process.
 * Maybe we do a board reset and kill it. Write 1 to Halt
 * in Status32.
 */

static void
arc_debug_kill (void)
{
  ENTERMSG;

  /* Do stuff */

  target_mourn_inferior ();
}


/* Function: arc_debug_load
 * Parameters :
 * 1. char * args: Arguments.
 * 2. int from_tty: Which terminal.
 * Returns : void.
 * Description: Load the program into mmemory via the JTAG interface.
 */

static void
arc_debug_load (char *args, int from_tty)
{
    /* Write to RAM of the ARC700 board by running through the sections .*/
    asection* bss_section;

    ENTERARGS("%s", args);

    generic_load(args, from_tty);

    /* Zero the BSS, if it exists.  */
    bss_section = bfd_get_section_by_name (exec_bfd, ".bss");

    if (bss_section)
    {
        CORE_ADDR     bss_addr = bfd_section_lma (exec_bfd, bss_section);
        bfd_size_type bss_size = bfd_get_section_size (bss_section);
        unsigned int  bytes;

        printf_filtered("Zeroing section .bss, size 0x%0x lma 0x%0x\n",
                        (unsigned int) bss_size, (unsigned int) bss_addr);

        bytes = arc_jtag_ops.jtag_memory_zero_fill((ARC_Address)  bss_addr,
                                                    (unsigned int) bss_size);
        if (bytes != (unsigned int) bss_size)
            warning ("load: error zeroing BSS section - only %u bytes zeroed\n", bytes);
    }
    else
    {
        DEBUG("%s: no BSS section\n", __FUNCTION__);
    }

    clear_symtab_users();

//  /* we now have a program ready for execution on the target */
    current_target.to_has_execution = 1;
}


/* Function: arc_debug_create_inferior
 * Parameters :
 * 1. char * exec_file:
 * 2. char * args:
 * 3. char ** env;
 * Returns : void.
 * Description: Set up sanity values for arc_debug_create_inferior. More thought
 * needed for this.
 */

static void
arc_debug_create_inferior (char *exec_file, char *args, char **env, int dummy)
{
    ENTERARGS("%s, %s", exec_file, args);

    /* If no exec file handed to us, get it from the exec-file command
       -- with a good, common error message if none is specified.  */
    if (exec_file == NULL)
        exec_file = get_exec_file (1);

    /* We don't really have a PID or anything, but GDB uses this value to check
       if the program is running. */
    inferior_ptid.pid = 42;

    clear_proceed_status();
    /* -1 means resume from current place
       TARGET_SIGNAL_0 means "don't give it any signal"
       Last arg should be true if you want to single step */

    //proceed ((CORE_ADDR) -1, TARGET_SIGNAL_0, 0);
    //proceed (bfd_get_start_address (exec_bfd), TARGET_SIGNAL_0, 0);
    // COMMENTED because proceed has been extracted out in run_command in GDB 6.6.

    /* must set the PC to the start address */
    write_pc (bfd_get_start_address (exec_bfd));
}


/* Function: arc_debug_mourn_inferior
 * Parameters :void.
 * Returns : void.
 * Description: Set up sanity values for arc_debug_create_inferior.
 *              More thought needed for this.
 */

static void
arc_debug_mourn_inferior (void)
{
    ENTERMSG;

    (void) unpush_target (&arc_debug_ops);
    generic_mourn_inferior ();
}


/* Function: arc_debug_thread_alive
 * Parameters :ptid_t ptid.
 * Returns : 1 always.
 * Description: Checks for return values .
 */

static int
arc_debug_thread_alive (ptid_t ptid)
{
    ENTERMSG;
    return 1;
}


/* Function: arc_debug_stop
 * Parameters: void
 * Returns: void.
 * Description: Stop the Processor. We stop by writing FH bit to Debug Register.
 *    write 1 to the FH bit in the Debug register after
 *    polling for the DEBUG register to have no loads pending .
 */
static void
arc_debug_stop (void)
{
    ENTERMSG;

    /* Stop using the FH bit in the debug register. */
    (void) arc_write_aux_register (ARC_HW_DEBUG_REGNUM, DEBUG_FORCE_HALT);
}


/* Helper routines for commands added.  */

/* Print Processor Variant Info.  */
static void
arc_print_processor_variant_info (char* arg, int from_tty)
{
    switch (arc_get_architecture())
    {
        case UNSUPPORTED:
            printf_filtered ("unsupported\n");
            break;
        case ARCompact:
            printf_filtered ("ARCompact\n");
            break;
        case ARC600:
            printf_filtered ("ARC600\n");
            break;
        case ARC700:
            printf_filtered ("ARC700\n");
            break;
        case A5:
            printf_filtered ("A5\n");
            break;
        case A4:
            printf_filtered ("A4\n");
            break;
    }
}


static void
arc_print_bcr_regs (char* arg, int from_tty)
{
    unsigned int i;

    for (i = 0; i < ELEMENTS_IN_ARRAY(arc_bcr_reg_info); i++)
    {
        ARC_HardwareRegisters hw_regno = arc_bcr_reg_info[i].hw_regno;
        ARC_RegisterContents  bcr_value;

        if (arc_read_aux_register (hw_regno, &bcr_value))
            printf_filtered("[%02x] %-15s : 0x%02x\n",
                            hw_regno, arc_bcr_reg_info[i].name, bcr_value);
    }

}


static void
arc_debug_jtag_reset_board (char* arg, int from_tty)
{
    arc_jtag_ops.jtag_reset_board();

    /* the ARC actionpoint registers are cleared upon reset, so it is necessary
     * to restore any actionpoints that were set
     */
     if (!arc_restore_actionpoints_after_reset())
        warning ("could not restore hardware actionpoints");
}


static void
arc_list_actionpoints (char* arg, int from_tty)
{
    /* gdb manages breakpoints by deleting them from the target as soon as it
     * has halted, then re-inserting them again immediately before execution is
     * resumed (no, I don't know why either, unless it is to make generating a
     * disassembly display easier by removing all the s/w b/ps from the code) -
     * so in order to display what actionpoints are currently in use, we must
     * temporarily re-insert the breakpoints!
     */
    insert_breakpoints();
    arc_display_actionpoints();
    remove_breakpoints();
}


/* Function: init_arc_debug_ops
 * Parameters: void
 * Returns: void.
 * Description: Initialize the jtag operations.
 */

static void
init_arc_debug_ops (void)
{
    ENTERMSG;

    arc_debug_ops.to_shortname = ARC_TARGET_NAME;
    arc_debug_ops.to_longname  = "Target for debugging an ARC700 board with JTAG.";
    arc_debug_ops.to_doc       = "Debug a remote ARC700 board via a JTAG";

    arc_debug_ops.to_open   = arc_debug_open;
    arc_debug_ops.to_close  = arc_debug_close;
    arc_debug_ops.to_attach = arc_debug_attach;
    arc_debug_ops.to_detach = arc_debug_detach;
    arc_debug_ops.to_resume = arc_debug_resume;
    arc_debug_ops.to_wait   = arc_debug_wait;

    arc_debug_ops.to_fetch_registers  = arc_debug_fetch_regs;
    arc_debug_ops.to_store_registers  = arc_debug_store_regs;
    arc_debug_ops.to_prepare_to_store = arc_debug_prepare_to_store;
    arc_debug_ops.to_xfer_partial     = arc_debug_xfer_partial;
    arc_debug_ops.to_files_info       = arc_debug_files_info;

    arc_debug_ops.to_insert_breakpoint = arc_debug_insert_breakpoint;
    arc_debug_ops.to_remove_breakpoint = arc_debug_remove_breakpoint;

    arc_debug_ops.to_kill = arc_debug_kill;
    arc_debug_ops.to_load = arc_debug_load;

    arc_debug_ops.to_create_inferior   = arc_debug_create_inferior;
    arc_debug_ops.to_mourn_inferior    = arc_debug_mourn_inferior;
    arc_debug_ops.to_thread_alive      = arc_debug_thread_alive;
    arc_debug_ops.to_stop              = arc_debug_stop;
    arc_debug_ops.to_terminal_inferior = NULL;

    arc_debug_ops.to_stratum = process_stratum;

    arc_debug_ops.to_has_all_memory = 1;
    arc_debug_ops.to_has_memory     = 1;
    arc_debug_ops.to_has_stack      = 1;
    arc_debug_ops.to_has_registers  = 1;
//  arc_debug_ops.to_has_execution  = 1;  /* defer setting this until the program has been loaded */

    arc_debug_ops.to_magic = OPS_MAGIC;
}


/* -------------------------------------------------------------------------- */
/*                               externally visible functions                 */
/* -------------------------------------------------------------------------- */

void
_initialize_arc_debug (void)
{
    ENTERMSG;

    init_arc_debug_ops ();
    add_target (&arc_debug_ops);

    /* register ARC-specific commands with gdb */

    add_setshow_boolean_cmd("arcjtag-debug-statemachine",
                            no_class,
                            &arc_jtag_ops.jtag_state_machine_debug,
                            "Set whether to print JTAG state machine debug messages.\n",
                            "Show whether to print JTAG state machine debug messages.\n",
                            "If set the JTAG state machine messages are printed.\n",
                            NULL,
                            NULL,
                            &setlist,
                            &showlist);

    add_setshow_uinteger_cmd("arcjtag-retry-count",
                             no_class,
                             &arc_jtag_ops.jtag_retry_count,
                             "Set the number of attempts to be made for a JTAG operation.\n",
                             "Show the number of attempts to be made for a JTAG operation.\n",
                             "Indicates the number of times a JTAG operation is attempted before returning a failure.\n",
                             /* "The number of times a JTAG operation is attempted \
                                 before returning a failure is %s.\n", */
                             NULL,
                             NULL,
                             &setlist,
                             &showlist);

    (void) add_cmd("arc-configuration",
                   class_info,
                   arc_print_processor_variant_info,
                   "Show ARC configuration information.",
                   &infolist);

    (void) add_cmd("arc-bcr-registers",
                   class_info,
                   arc_print_bcr_regs,
                   "Show Build Configuration Registers in the ARC processor variant.",
                   &infolist);

    (void) add_cmd("arc-reset-board",
                   class_obscure,
                   arc_debug_jtag_reset_board,
                   "Reset the board.",
                   &cmdlist);

    (void) add_cmd("arc-list-actionpoints",
                   class_obscure,
                   arc_list_actionpoints,
                   "List the actionpoints.",
                   &cmdlist);
}


/* Get processor out of user mode. */
ARC_RegisterContents arc_clear_status32_user_bit (void)
{
    ARC_RegisterContents status32 = 0;

    if (arc_read_aux_register (ARC_HW_STATUS32_REGNUM, &status32))
    {
        /* if the User bit is actually set */
        if (status32 & STATUS32_USER)
            if (!arc_write_aux_register(ARC_HW_STATUS32_REGNUM,  status32 & ~STATUS32_USER))
                warning("Can not clear User bit in STATUS32 register");
    }
    else
        warning("Can not read STATUS32 register");

    return status32;
}


/* Restore a saved status32; use with arc_clear_status32_user_bit. */
void arc_restore_status32_user_bit (ARC_RegisterContents status32)
{
    /* if the User bit was actually cleared */
    if (status32 & STATUS32_USER)
        if (!arc_write_aux_register(ARC_HW_STATUS32_REGNUM, status32))
            warning("Can not restore User bit in STATUS32 register");
}



Boolean arc_read_aux_register  (ARC_RegisterNumber hwregno, ARC_RegisterContents* contents)
{
    if (arc_jtag_ops.jtag_read_aux_reg(hwregno, contents) == JTAG_SUCCESS)
    {
         DEBUG("arc_read_aux_register: hwregno = %d, contents = 0x%08X\n", hwregno, *contents);
         return TRUE;
    }

    warning("Failure reading auxiliary register 0x%x", hwregno);
    return FALSE;
}


Boolean arc_write_aux_register (ARC_RegisterNumber hwregno, ARC_RegisterContents contents)
{
    ENTERARGS("hwregno = %d, contents = 0x%08X", hwregno, contents);

    if (arc_jtag_ops.jtag_write_aux_reg(hwregno, contents) == JTAG_SUCCESS)
         return TRUE;

    warning("Failure writing 0x%x to auxiliary register 0x%x", contents, hwregno);
    return FALSE;
}

/******************************************************************************/
